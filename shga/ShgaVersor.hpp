// Sh: A GPU metaprogramming language.
//
// Copyright (c) 2003 University of Waterloo Computer Graphics Laboratory
// Project administrator: Michael D. McCool
// Authors: Bryan Chan 
//          
// 
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
// 
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 
// 1. The origin of this software must not be misrepresented; you must
// not claim that you wrote the original software. If you use this
// software in a product, an acknowledgment in the product documentation
// would be appreciated but is not required.
// 
// 2. Altered source versions must be plainly marked as such, and must
// not be misrepresented as being the original software.
// 
// 3. This notice may not be removed or altered from any source
// distribution.
//////////////////////////////////////////////////////////////////////////////
#ifndef SHGA_VERSOR_HPP 
#define SHGA_VERSOR_HPP 

#include "ShAttrib.hpp"
#include "ShgaConstants.hpp"
#include "ShgaBase.hpp"

namespace Shga {

using namespace SH;


/** \file ShgaVersor.hpp
 * This is an implementation of a versor in a geometric algebra with the 
 * specified signature and dimension.
 * Currently, only odd or even versors are supported, since general versors
 * probably have less geometric significance.
 *
 * Many of the ideas are based on the papers "Gaigen: A Geometric
 * Algebra Implementation Generator" (Fontijne 2002) and
 * "The Making of GABLE" (Mann, Dorst & Bouma )
 */

// TODO add Daniel's license at the top since I have looked briefly at code generated by Gaigen,
// and probably borrowed a lot of good GA implementation paradigms.

/** \brief Versors in a geometric algebra with the signature defined by P, N, Z, R 
 * The ShgaVersor represents a versor in a geometric algebra with 
 * basis elements {e1,e2,...ed} where
 * d = P + N + 2R is the degree of the algebra nd 
 * A) e_i * e_i = 1 for 0 <= i < P
 * B) e_i * e_i = -1 for P <= i < N + P
 * C) e_i * e_i = 0 for  N + P <= i < P + N + Z 
 *
 * (TODO not implemented yet)
 * D) And for pairs (e_{N+2i}, e_{N+2i+1}) where 0 <= i < R, 
 *    e_{N+2i} * e{N+2i+1} = 1
 * Except as defined in C, all other pairs of basis elements are orthogonal 
 * ( i.e. e_i * e_j = 0, except when i,j >= N && floor( i / 2 ) == floor( j / 2 ) ) 
 *
 * This can be easily extended later to handle basis elements with zero signatures,
 * or pairs of basis elements which multiply to -1 and square zero. 
 *
 *

/* TODO (for now T is by default ShAttrib4f as defined in ShgaConstants.hpp)
 * The typename T is a class used to store coefficients.  For now this must be
 * a subclass of ShAttrib?f and have T::typesize declared.  The ShgaAlgebra class
 * will use this typesize to determine how to best pack the coefficients into 
 * an array of Ts.
 */
template<typename T, int P, int N>
class ShgaVersor: public ShgaBase<T, P, N>
{
  public:
    typedef ShgaVersor<T, P, N> VersorType; 

    /** \brief Constructor for ShgaVersor
     * Creates a zero versor
     */
    ShgaVersor();
    ShgaVersor(const VersorType &b);

    /** \brief Scalar construcctor for ShgaVersor
     * Creates a scalar versor
     */
    ShgaVersor( double scalar );
    ShgaVersor( ShAttrib1f scalar ); 

    /** \brief Constructor for ShgaVersors
     * Creates a zeroed versor with the given grade elements
     */
    ShgaVersor( int grades );
    /** \brief Constructor for ShgaVersor
     * grades is a bit mask specifying which grades are included
     * coeff is an array of coefficients for all basis elements from
     *  the specified grades, in lexicographical order
     */
    ShgaVersor( int grades, double coeff[] ); 

    /** \brief Constructor for ShgaVersor
     * This one is used to create a blade from coefficients given in ShAttribs
     *
     * TODO: improve this
     */
    ShgaVersor( int grades, ShAttrib1f coeff[] ); 

    // TODO determine if this works for general T
    ShgaVersor( int grades, const T coeff[] ); 
   

    /** \brief Destructor for ShgaVersor.
     */
    ~ShgaVersor();

    /** \brief assignment operator
     * Makes a copy of b's data/memory object
     */
    VersorType& operator=( const VersorType &b );

    // Gets the specified basis element 
    // basisElement is specified using bitwise-or on SHGA_E? 
    ShAttrib1f& operator()( int basisElement ); 

    // TODO check if this actually makes Attrib1f constant??
    const ShAttrib1f operator()( int basisElement ) const; 

    /** \brief Returns a versor with only the requested grades
     */
    VersorType grade( int grades );

    /** \brief Geometric Product
     */
    VersorType operator*( const VersorType &b ) const; 
    VersorType& operator*=( const VersorType &b ); 

    /** \brief left contraction inner product (the default)
     *
     * TODO implement others
     */
    VersorType operator<<( const VersorType &b ) const;
    VersorType& operator<<=( const VersorType &b );

    /** \brief Outer product
     */
    VersorType operator^( const VersorType &b ) const;
    VersorType& operator^=( const VersorType &b );

    /** \brief Geometric product with right inverse 
     * TODO 
    VersorType operator/( const VersorType &b ) const;
    VersorType& operator/=( const VersorType &b );
   */

    /** \brief delta product 
    VersorType operator|( const VersorType &b ) const;
    VersorType& operator|=( const VersorType &b ) ;
     */

    /** \brief implementation of grade involution 
     */
    VersorType gradeInvolution() const;

    /** \brief implementation of reverse 
     */
    VersorType reverse() const;

    /** \brief implementation of Clifford conjugate 
     */
    VersorType cliffordConjugate() const;


    /** \brief implementation of dual
     */
    VersorType dual() const;

    /** \brief implementation of dual
     */
    VersorType inverse() const;

    /** \brief meet 
    VersorType meet( const VersorType &b ) const;
     */

    /** \brief join 
    VersorType join( const VersorType &b ) const;
     */

    /** \brief Addition/subtraction 
    VersorType operator+( const VersorType &b ) const;
    VersorType& operator+=( const VersorType &b );
    VersorType operator-( const VersorType &b ) const;
    VersorType& operator-=( const VersorType &b );
    */

    // this function cannot be used on GPU (no way to output text,
    // no way i'm porting STL strings to the GPU)
    std::string toString() const;

  private:
    // updates size and allocation for m_coeff based on current m_grades 
    // TODO decide if this should zero coefficients or not
    void updateSize(); 

    // run binary op sequence where this is implicitly src1, b is src2
    void runMadSequence( typename ShgaBase<T, P, N>::BinaryOpSequence &bos, 
        const VersorType &b, VersorType &dest ) const;

    // run unary op sequence where this is implicitly src1
    void runCopySequence( typename ShgaBase<T, P, N>::UnaryOpSequence &uos, 
        VersorType &dest ) const;

    int m_grades;
    int size;  
    T* m_coeff; // coefficients array (each T holds T::typesize coefficients)
};

typedef ShgaVersor<ShAttrib4f,3,0> e3ga; 

}

#include "ShgaVersorImpl.hpp"

#endif
