// Sh: A GPU metaprogramming language.
//
// Copyright (c) 2003 University of Waterloo Computer Graphics Laboratory
// Project administrator: Michael D. McCool
// Authors: Bryan Chan 
//          
// 
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
// 
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 
// 1. The origin of this software must not be misrepresented; you must
// not claim that you wrote the original software. If you use this
// software in a product, an acknowledgment in the product documentation
// would be appreciated but is not required.
// 
// 2. Altered source versions must be plainly marked as such, and must
// not be misrepresented as being the original software.
// 
// 3. This notice may not be removed or altered from any source
// distribution.
//////////////////////////////////////////////////////////////////////////////
#ifndef SHGA_VERSOR_HPP 
#define SHGA_VERSOR_HPP 

#include "ShAttrib.hpp"
#include "ShgaConstants.hpp"
#include "ShgaBase.hpp"

namespace Shga {

using namespace SH;


/** \file ShgaMultivector.hpp
 * This is an implementation of a multivector in a geometric algebra with the 
 * specified signature and dimension.
 * Currently, only odd or even multivectors are supported, since general multivectors
 * probably have less geometric significance.
 *
 * Many of the ideas are based on the papers "Gaigen: A Geometric
 * Algebra Implementation Generator" (Fontijne 2002) and
 * "The Making of GABLE" (Mann, Dorst & Bouma )
 */

// TODO add Daniel's license at the top since I have looked briefly at code generated by Gaigen,
// and probably borrowed a lot of good GA implementation paradigms.

/** \brief Multivectors in a geometric algebra with the signature defined by P, N, Z, R 
 * The ShgaMultivector represents a multivector in a geometric algebra with 
 * basis elements {e1,e2,...ed} where
 * d = P + N + 2R is the degree of the algebra nd 
 * A) e_i * e_i = 1 for 0 <= i < P
 * B) e_i * e_i = -1 for P <= i < N + P
 * C) e_i * e_i = 0 for  N + P <= i < P + N + Z 
 *
 * (TODO not implemented yet)
 * D) And for pairs (e_{N+2i}, e_{N+2i+1}) where 0 <= i < R, 
 *    e_{N+2i} * e{N+2i+1} = 1
 * Except as defined in C, all other pairs of basis elements are orthogonal 
 * ( i.e. e_i * e_j = 0, except when i,j >= N && floor( i / 2 ) == floor( j / 2 ) ) 
 *
 * This can be easily extended later to handle basis elements with zero signatures,
 * or pairs of basis elements which multiply to -1 and square zero. 
 *
 *

/* TODO (for now T is by default ShAttrib4f as defined in ShgaConstants.hpp)
 * The typename T is a class used to store coefficients.  For now this must be
 * a subclass of ShAttrib?f and have T::typesize declared.  The ShgaAlgebra class
 * will use this typesize to determine how to best pack the coefficients into 
 * an array of Ts.
 */
template<typename T, int P, int N>
class ShgaMultivector: public ShgaBase<T, P, N>
{
  public:
    typedef ShgaMultivector<T, P, N> MultivectorType; 

    /** \brief Constructor for ShgaMultivector
     * Creates a zero multivector
     */
    ShgaMultivector();
    ShgaMultivector(const MultivectorType &b);

    /** \brief Scalar construcctor for ShgaMultivector
     * Creates a scalar multivector
     */
    ShgaMultivector( double scalar );
    ShgaMultivector( ShAttrib1f scalar ); 

    /** \brief Constructor for ShgaMultivectors
     * Creates a zeroed multivector with the given grade elements
     */
    ShgaMultivector( int grades );
    /** \brief Constructor for ShgaMultivector
     * grades is a bit mask specifying which grades are included
     * coeff is an array of coefficients for all basis elements from
     *  the specified grades, in lexicographical order
     */
    ShgaMultivector( int grades, double coeff[] ); 

    /** \brief Constructor for ShgaMultivector
     * This one is used to create a blade from coefficients given in ShAttribs
     *
     * TODO: improve this
     */
    ShgaMultivector( int grades, ShAttrib1f coeff[] ); 

    // TODO determine if this works for general T
    ShgaMultivector( int grades, const T coeff[] ); 
   

    /** \brief Destructor for ShgaMultivector.
     */
    ~ShgaMultivector();

    /** \brief assignment operator
     * Makes a copy of b's data/memory object
     */
    MultivectorType& operator=( const MultivectorType &b );

    // Gets the specified basis element 
    // basisElement is specified using bitwise-or on SHGA_E? 
    ShAttrib1f operator()( int basisElement ) const; 

    /** \brief Returns a multivector with only the requested grades
     */
    MultivectorType grade( int grades );

    /** \brief Geometric Product
     */
    MultivectorType operator*( const MultivectorType &b ) const; 
    MultivectorType& operator*=( const MultivectorType &b ); 

    /** \brief left contraction inner product (the default)
     *
     * TODO implement others
     */
    MultivectorType operator<<( const MultivectorType &b ) const;
    MultivectorType& operator<<=( const MultivectorType &b );

    /** \brief Outer product
     */
    MultivectorType operator^( const MultivectorType &b ) const;
    MultivectorType& operator^=( const MultivectorType &b );

    /** \brief Geometric product with right inverse 
     * TODO 
    MultivectorType operator/( const MultivectorType &b ) const;
    MultivectorType& operator/=( const MultivectorType &b );
   */

    /** \brief delta product 
    MultivectorType operator|( const MultivectorType &b ) const;
    MultivectorType& operator|=( const MultivectorType &b ) ;
     */

    /** \brief implementation of grade involution 
     */
    MultivectorType gradeInvolution() const;

    /** \brief implementation of reverse 
     */
    MultivectorType reverse() const;

    /** \brief implementation of Clifford conjugate 
     */
    MultivectorType cliffordConjugate() const;


    /** \brief implementation of dual
     */
    MultivectorType dual() const;

    /** \brief implementation of dual
     */
    MultivectorType inverse() const;

    /** \brief meet 
    MultivectorType meet( const MultivectorType &b ) const;
     */

    /** \brief join 
    MultivectorType join( const MultivectorType &b ) const;
     */

    MultivectorType operator+( const MultivectorType &b ) const;
    MultivectorType& operator+=( const MultivectorType &b );
    /*
    MultivectorType operator-( const MultivectorType &b ) const;
    MultivectorType& operator-=( const MultivectorType &b );
    */

    // this function cannot be used on GPU (no way to output text,
    // no way i'm porting STL strings to the GPU)
    std::string toString() const;

  private:
    // updates size and allocation for m_coeff based on current m_grades 
    // TODO decide if this should zero coefficients or not
    void updateSize(); 

    // run binary op sequence where this is implicitly src1, b is src2
    void runMadSequence( typename ShgaBase<T, P, N>::BinaryOpSequence &bos, 
        const MultivectorType &b, MultivectorType &dest ) const;

    // run unary op sequence where this is implicitly src1
    void runAddSequence( typename ShgaBase<T, P, N>::UnaryOpSequence &uos, 
        MultivectorType &dest ) const;

    int m_grades;
    int size;  
    T* m_coeff; // coefficients array (each T holds T::typesize coefficients)
};

typedef ShgaMultivector<ShAttrib4f,3,0> e3ga; 

}

#include "ShgaMultivectorImpl.hpp"

#endif
