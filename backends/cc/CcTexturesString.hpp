// Sh: A GPU metaprogramming language.
//
// Copyright 2003-2006 Serious Hack Inc.
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
// MA  02110-1301, USA
//////////////////////////////////////////////////////////////////////////////
const char* cc_texture_string[] = {
"// Sh: A GPU metaprogramming language.\n",
"//\n",
"// Copyright 2003-2006 Serious Hack Inc.\n",
"// \n",
"// This library is free software; you can redistribute it and/or\n",
"// modify it under the terms of the GNU Lesser General Public\n",
"// License as published by the Free Software Foundation; either\n",
"// version 2.1 of the License, or (at your option) any later version.\n",
"//\n"
"// This library is distributed in the hope that it will be useful,\n",
"// but WITHOUT ANY WARRANTY; without even the implied warranty of\n",
"// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n",
"// Lesser General Public License for more details.\n",
"//\n",
"// You should have received a copy of the GNU Lesser General Public\n",
"// License along with this library; if not, write to the Free Software\n",
"// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n",
"// MA  02110-1301, USA\n",
"//////////////////////////////////////////////////////////////////////////////\n",
"\n",
"/** @file CcTextures.hpp\n",
" *\n",
" * This implements 1D, 2D, and 3D texture lookup functions, \n",
" * clamps texture coordinates, but  \n",
" *\n",
" * Assume interpolation/mipmapping afterwards \n",
" *\n",
" * src indices are assumed to be integers, even if the int \n",
" * allows floating point values.\n",
" *\n",
" * All of the parameters such as tuple-size, etc.\n",
" * will be known statically at time of code emission, so they\n",
" * are all template parameters.\n",
" */\n",
"\n",
"// @todo type\n",
"// add casting code for when MemoryType is not equivalent to the type used in computation\n",
"\n",
"// floor and clamp to [0, max) for aninteger lookup\n",
"template<typename T>\n",
"inline int sh_cc_backend_nearest(T value)\n",
"{\n",
"  return (int)(floor(static_cast<double>(value))); \n",
"}\n",
"\n",
"struct sh_gcc_backend_wrap_clamp\n",
"{\n",
"  static inline int wrap(int src, int Max) \n",
"  {\n",
"    return src >= Max ? Max - 1 : (src < 0 ? 0 : src);\n",
"  }\n",
"};\n",
"\n",
"struct sh_gcc_backend_wrap_repeat\n",
"{\n",
"  static int wrap(int src, int Max) \n",
"  {\n",
"    src %= Max;\n",
"    if(src < 0) src += Max;\n",
"    return src; \n",
"  }\n",
"};\n",
"\n",
"template<int TexDims, int TexSize, int TexWidth, int TexHeight, int TexDepth, typename TexType,\n",
"  typename SrcWrap, typename IndexType, typename MemoryType> \n",
"void sh_cc_backend_lookupi(const void *texture, IndexType *src, MemoryType *dest)\n",
"{\n",
"  const TexType* data = reinterpret_cast<const TexType*>(texture);\n",
"  int index = 0;\n",
"  if(TexDims == 3) index = SrcWrap::wrap(sh_cc_backend_nearest(src[2]), TexDepth);\n",
"  if(TexDims >= 2) index = SrcWrap::wrap(sh_cc_backend_nearest(src[1]), TexHeight) \n",
"      + TexHeight * index;\n",
"  index = SrcWrap::wrap(sh_cc_backend_nearest(src[0]), TexWidth)\n",
"          + TexWidth * index;\n",
"\n",
"  int start = index * TexSize; \n",
"  for(int i = 0; i < TexSize; ++i) {\n",
"    dest[i] = static_cast<MemoryType>(data[start + i]); \n",
"  }\n",
"}\n",
"\n",
"template<int TexDims, int TexSize, int TexWidth, int TexHeight, int TexDepth, typename TexType,\n",
"  typename SrcWrap, typename IndexType, typename MemoryType> \n",
"void sh_cc_backend_lookup(const void *texture, IndexType *src, MemoryType *dest)\n",
"{\n",
"  IndexType scaled_src[TexDims];\n",
"  scaled_src[0] = TexWidth * src[0];\n",
"  if(TexDims > 1) scaled_src[1] = TexHeight * src[1];\n",
"  if(TexDims > 2) scaled_src[2] = TexDepth * src[2];\n",
"\n",
"  sh_cc_backend_lookupi<TexDims, TexSize, TexWidth, TexHeight, TexDepth, TexType, \n",
"    SrcWrap>(texture, scaled_src, dest);\n",
"}\n",
"\n",
""};
