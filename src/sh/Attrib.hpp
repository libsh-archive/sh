// WARNING - DO NOT EDIT THIS FILE:
// This file was automatically generated from scripts/Attrib.hpp.py.
// If you wish to change it, edit that file instead.
//
// ---
//
// Sh: A GPU metaprogramming language.
//
// Copyright 2003-2006 Serious Hack Inc.
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
// MA  02110-1301, USA
//////////////////////////////////////////////////////////////////////////////

#ifndef SH_SHATTRIB_HPP
#define SH_SHATTRIB_HPP

#ifndef SH_DO_NOT_INCLUDE_GENERIC_IMPL
#  define SH_DO_NOT_INCLUDE_GENERIC_IMPL
#  include "Generic.hpp"
#  undef SH_DO_NOT_INCLUDE_GENERIC_IMPL
#else
#  include "Generic.hpp"
#endif
namespace SH {

/** A generic attribute (or parameter) holding N values.
 * 
 * The reason we have the Swizzle template argument is so that
 * swizzled variables, which need to be copied (i.e. have an ASN
 * statement generated) when another variable is initialized through
 * them, may otherwise be simply placed into new variables (through
 * copy constructor eliding, as per paragraph 12.8.15 of the C++
 * standard), causing variables to share VariableNodes when they
 * shouldn't. By making swizzled variables separate types we enforce
 * calling a conversion constructor instead, which cannot be elided.
 * If this paragraph confuses you, and you're not modifying Sh
 * internals, you may safely ignore it.
 *
 */
template<int N, BindingType Binding, typename T=float, SemanticType Semantic=ATTRIB, bool Swizzled=false>
class Attrib : public Generic<N, T> {
public:
  typedef T storage_type;
  typedef typename HostType<T>::type host_type; 
  typedef typename MemType<T>::type mem_type; 
  static const BindingType binding_type = Binding;
  static const SemanticType semantic_type = Semantic;

  typedef Attrib<N, INPUT, T, Semantic> InputType;
  typedef Attrib<N, OUTPUT, T, Semantic> OutputType;
  typedef Attrib<N, INOUT, T, Semantic> InOutType;
  typedef Attrib<N, TEMP, T, Semantic> TempType;
  typedef Attrib<N, CONST, T, Semantic> ConstType;
  Attrib();
  
  template<typename T2>
  Attrib(const Generic<N, T2>& other);
  Attrib(const Attrib<N, Binding, T, Semantic, Swizzled>& other);
  
  template<typename T2>
  Attrib(const Attrib<N, Binding, T2, Semantic, Swizzled>& other);
  Attrib(const VariableNodePtr& node, const Swizzle& swizzle, bool neg);
  explicit Attrib(const host_type data[N]);
  
  ~Attrib();

  
  template<typename T2>
  Attrib& operator=(const Generic<N, T2>& other);
  
  template<typename T2>
  Attrib& operator=(const Attrib<N, Binding, T2, Semantic, Swizzled>& other);
  Attrib& operator=(const Attrib<N, Binding, T, Semantic, Swizzled>& other);

  Attrib& operator=(const Program& prg);

  
  Attrib& operator++();
  
  Attrib& operator--();
  
  template<typename T2>
  Attrib& operator+=(const Generic<N, T2>& right);
  
  template<typename T2>
  Attrib& operator-=(const Generic<N, T2>& right);
  
  template<typename T2>
  Attrib& operator*=(const Generic<N, T2>& right);
  
  template<typename T2>
  Attrib& operator/=(const Generic<N, T2>& right);
  
  template<typename T2>
  Attrib& operator%=(const Generic<N, T2>& right);
  Attrib& operator*=(host_type);
  Attrib& operator/=(host_type);
  Attrib& operator%=(host_type);
  Attrib& operator+=(host_type);
  Attrib& operator-=(host_type);
  
  template<typename T2>
  Attrib& operator+=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator-=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator*=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator/=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator%=(const Generic<1, T2>&);
  Attrib<1, Binding, T, Semantic, true> operator()(int) const;
  Attrib<2, Binding, T, Semantic, true> operator()(int, int) const;
  Attrib<3, Binding, T, Semantic, true> operator()(int, int, int) const;
  Attrib<4, Binding, T, Semantic, true> operator()(int, int, int, int) const;
  Attrib<1, Binding, T, Semantic, true> operator[](int) const;
  
  template<int N2>
  Attrib<N2, Binding, T, Semantic, true> swiz(int indices[]) const;
  
  Attrib operator-() const;
  private:
    typedef Generic<N, T> ParentType;
};

template<BindingType Binding, typename T, SemanticType Semantic, bool Swizzled>
class Attrib<1, Binding, T, Semantic, Swizzled> : public Generic<1, T> {
public:
  typedef T storage_type;
  typedef typename HostType<T>::type host_type; 
  typedef typename MemType<T>::type mem_type; 
  static const BindingType binding_type = Binding;
  static const SemanticType semantic_type = Semantic;

  typedef Attrib<1, INPUT, T, Semantic> InputType;
  typedef Attrib<1, OUTPUT, T, Semantic> OutputType;
  typedef Attrib<1, INOUT, T, Semantic> InOutType;
  typedef Attrib<1, TEMP, T, Semantic> TempType;
  typedef Attrib<1, CONST, T, Semantic> ConstType;
  Attrib();
  
  template<typename T2>
  Attrib(const Generic<1, T2>& other);
  Attrib(const Attrib<1, Binding, T, Semantic, Swizzled>& other);
  
  template<typename T2>
  Attrib(const Attrib<1, Binding, T2, Semantic, Swizzled>& other);
  Attrib(const VariableNodePtr& node, const Swizzle& swizzle, bool neg);
  explicit Attrib(const host_type data[1]);
  
  Attrib(host_type);
  
  ~Attrib();

  
  template<typename T2>
  Attrib& operator=(const Generic<1, T2>& other);
  
  template<typename T2>
  Attrib& operator=(const Attrib<1, Binding, T2, Semantic, Swizzled>& other);
  Attrib& operator=(const Attrib<1, Binding, T, Semantic, Swizzled>& other);

  Attrib& operator=(host_type other);

  Attrib& operator=(const Program& prg);

  
  Attrib& operator++();
  
  Attrib& operator--();
  
  template<typename T2>
  Attrib& operator+=(const Generic<1, T2>& right);
  
  template<typename T2>
  Attrib& operator-=(const Generic<1, T2>& right);
  
  template<typename T2>
  Attrib& operator*=(const Generic<1, T2>& right);
  
  template<typename T2>
  Attrib& operator/=(const Generic<1, T2>& right);
  
  template<typename T2>
  Attrib& operator%=(const Generic<1, T2>& right);
  Attrib& operator*=(host_type);
  Attrib& operator/=(host_type);
  Attrib& operator%=(host_type);
  Attrib& operator+=(host_type);
  Attrib& operator-=(host_type);
  Attrib<1, Binding, T, Semantic, true> operator()(int) const;
  Attrib<2, Binding, T, Semantic, true> operator()(int, int) const;
  Attrib<3, Binding, T, Semantic, true> operator()(int, int, int) const;
  Attrib<4, Binding, T, Semantic, true> operator()(int, int, int, int) const;
  Attrib<1, Binding, T, Semantic, true> operator[](int) const;
  
  template<int N2>
  Attrib<N2, Binding, T, Semantic, true> swiz(int indices[]) const;
  
  Attrib operator-() const;
  private:
    typedef Generic<1, T> ParentType;
};

template<BindingType Binding, typename T, SemanticType Semantic, bool Swizzled>
class Attrib<2, Binding, T, Semantic, Swizzled> : public Generic<2, T> {
public:
  typedef T storage_type;
  typedef typename HostType<T>::type host_type; 
  typedef typename MemType<T>::type mem_type; 
  static const BindingType binding_type = Binding;
  static const SemanticType semantic_type = Semantic;

  typedef Attrib<2, INPUT, T, Semantic> InputType;
  typedef Attrib<2, OUTPUT, T, Semantic> OutputType;
  typedef Attrib<2, INOUT, T, Semantic> InOutType;
  typedef Attrib<2, TEMP, T, Semantic> TempType;
  typedef Attrib<2, CONST, T, Semantic> ConstType;
  Attrib();
  
  template<typename T2>
  Attrib(const Generic<2, T2>& other);
  Attrib(const Attrib<2, Binding, T, Semantic, Swizzled>& other);
  
  template<typename T2>
  Attrib(const Attrib<2, Binding, T2, Semantic, Swizzled>& other);
  Attrib(const VariableNodePtr& node, const Swizzle& swizzle, bool neg);
  explicit Attrib(const host_type data[2]);
  
  Attrib(host_type, host_type);
  template<typename T2, typename T3>
  Attrib(const Generic<1, T2>&, const Generic<1, T3>&);
  
  ~Attrib();

  
  template<typename T2>
  Attrib& operator=(const Generic<2, T2>& other);
  
  template<typename T2>
  Attrib& operator=(const Attrib<2, Binding, T2, Semantic, Swizzled>& other);
  Attrib& operator=(const Attrib<2, Binding, T, Semantic, Swizzled>& other);

  Attrib& operator=(const Program& prg);

  
  Attrib& operator++();
  
  Attrib& operator--();
  
  template<typename T2>
  Attrib& operator+=(const Generic<2, T2>& right);
  
  template<typename T2>
  Attrib& operator-=(const Generic<2, T2>& right);
  
  template<typename T2>
  Attrib& operator*=(const Generic<2, T2>& right);
  
  template<typename T2>
  Attrib& operator/=(const Generic<2, T2>& right);
  
  template<typename T2>
  Attrib& operator%=(const Generic<2, T2>& right);
  Attrib& operator*=(host_type);
  Attrib& operator/=(host_type);
  Attrib& operator%=(host_type);
  Attrib& operator+=(host_type);
  Attrib& operator-=(host_type);
  
  template<typename T2>
  Attrib& operator+=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator-=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator*=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator/=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator%=(const Generic<1, T2>&);
  Attrib<1, Binding, T, Semantic, true> operator()(int) const;
  Attrib<2, Binding, T, Semantic, true> operator()(int, int) const;
  Attrib<3, Binding, T, Semantic, true> operator()(int, int, int) const;
  Attrib<4, Binding, T, Semantic, true> operator()(int, int, int, int) const;
  Attrib<1, Binding, T, Semantic, true> operator[](int) const;
  
  template<int N2>
  Attrib<N2, Binding, T, Semantic, true> swiz(int indices[]) const;
  
  Attrib operator-() const;
  private:
    typedef Generic<2, T> ParentType;
};

template<BindingType Binding, typename T, SemanticType Semantic, bool Swizzled>
class Attrib<3, Binding, T, Semantic, Swizzled> : public Generic<3, T> {
public:
  typedef T storage_type;
  typedef typename HostType<T>::type host_type; 
  typedef typename MemType<T>::type mem_type; 
  static const BindingType binding_type = Binding;
  static const SemanticType semantic_type = Semantic;

  typedef Attrib<3, INPUT, T, Semantic> InputType;
  typedef Attrib<3, OUTPUT, T, Semantic> OutputType;
  typedef Attrib<3, INOUT, T, Semantic> InOutType;
  typedef Attrib<3, TEMP, T, Semantic> TempType;
  typedef Attrib<3, CONST, T, Semantic> ConstType;
  Attrib();
  
  template<typename T2>
  Attrib(const Generic<3, T2>& other);
  Attrib(const Attrib<3, Binding, T, Semantic, Swizzled>& other);
  
  template<typename T2>
  Attrib(const Attrib<3, Binding, T2, Semantic, Swizzled>& other);
  Attrib(const VariableNodePtr& node, const Swizzle& swizzle, bool neg);
  explicit Attrib(const host_type data[3]);
  
  Attrib(host_type, host_type, host_type);
  template<typename T2, typename T3, typename T4>
  Attrib(const Generic<1, T2>&, const Generic<1, T3>&, const Generic<1, T4>&);
  
  ~Attrib();

  
  template<typename T2>
  Attrib& operator=(const Generic<3, T2>& other);
  
  template<typename T2>
  Attrib& operator=(const Attrib<3, Binding, T2, Semantic, Swizzled>& other);
  Attrib& operator=(const Attrib<3, Binding, T, Semantic, Swizzled>& other);

  Attrib& operator=(const Program& prg);

  
  Attrib& operator++();
  
  Attrib& operator--();
  
  template<typename T2>
  Attrib& operator+=(const Generic<3, T2>& right);
  
  template<typename T2>
  Attrib& operator-=(const Generic<3, T2>& right);
  
  template<typename T2>
  Attrib& operator*=(const Generic<3, T2>& right);
  
  template<typename T2>
  Attrib& operator/=(const Generic<3, T2>& right);
  
  template<typename T2>
  Attrib& operator%=(const Generic<3, T2>& right);
  Attrib& operator*=(host_type);
  Attrib& operator/=(host_type);
  Attrib& operator%=(host_type);
  Attrib& operator+=(host_type);
  Attrib& operator-=(host_type);
  
  template<typename T2>
  Attrib& operator+=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator-=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator*=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator/=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator%=(const Generic<1, T2>&);
  Attrib<1, Binding, T, Semantic, true> operator()(int) const;
  Attrib<2, Binding, T, Semantic, true> operator()(int, int) const;
  Attrib<3, Binding, T, Semantic, true> operator()(int, int, int) const;
  Attrib<4, Binding, T, Semantic, true> operator()(int, int, int, int) const;
  Attrib<1, Binding, T, Semantic, true> operator[](int) const;
  
  template<int N2>
  Attrib<N2, Binding, T, Semantic, true> swiz(int indices[]) const;
  
  Attrib operator-() const;
  private:
    typedef Generic<3, T> ParentType;
};

template<BindingType Binding, typename T, SemanticType Semantic, bool Swizzled>
class Attrib<4, Binding, T, Semantic, Swizzled> : public Generic<4, T> {
public:
  typedef T storage_type;
  typedef typename HostType<T>::type host_type; 
  typedef typename MemType<T>::type mem_type; 
  static const BindingType binding_type = Binding;
  static const SemanticType semantic_type = Semantic;

  typedef Attrib<4, INPUT, T, Semantic> InputType;
  typedef Attrib<4, OUTPUT, T, Semantic> OutputType;
  typedef Attrib<4, INOUT, T, Semantic> InOutType;
  typedef Attrib<4, TEMP, T, Semantic> TempType;
  typedef Attrib<4, CONST, T, Semantic> ConstType;
  Attrib();
  
  template<typename T2>
  Attrib(const Generic<4, T2>& other);
  Attrib(const Attrib<4, Binding, T, Semantic, Swizzled>& other);
  
  template<typename T2>
  Attrib(const Attrib<4, Binding, T2, Semantic, Swizzled>& other);
  Attrib(const VariableNodePtr& node, const Swizzle& swizzle, bool neg);
  explicit Attrib(const host_type data[4]);
  
  Attrib(host_type, host_type, host_type, host_type);
  template<typename T2, typename T3, typename T4, typename T5>
  Attrib(const Generic<1, T2>&, const Generic<1, T3>&, const Generic<1, T4>&, const Generic<1, T5>&);
  
  ~Attrib();

  
  template<typename T2>
  Attrib& operator=(const Generic<4, T2>& other);
  
  template<typename T2>
  Attrib& operator=(const Attrib<4, Binding, T2, Semantic, Swizzled>& other);
  Attrib& operator=(const Attrib<4, Binding, T, Semantic, Swizzled>& other);

  Attrib& operator=(const Program& prg);

  
  Attrib& operator++();
  
  Attrib& operator--();
  
  template<typename T2>
  Attrib& operator+=(const Generic<4, T2>& right);
  
  template<typename T2>
  Attrib& operator-=(const Generic<4, T2>& right);
  
  template<typename T2>
  Attrib& operator*=(const Generic<4, T2>& right);
  
  template<typename T2>
  Attrib& operator/=(const Generic<4, T2>& right);
  
  template<typename T2>
  Attrib& operator%=(const Generic<4, T2>& right);
  Attrib& operator*=(host_type);
  Attrib& operator/=(host_type);
  Attrib& operator%=(host_type);
  Attrib& operator+=(host_type);
  Attrib& operator-=(host_type);
  
  template<typename T2>
  Attrib& operator+=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator-=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator*=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator/=(const Generic<1, T2>&);
  
  template<typename T2>
  Attrib& operator%=(const Generic<1, T2>&);
  Attrib<1, Binding, T, Semantic, true> operator()(int) const;
  Attrib<2, Binding, T, Semantic, true> operator()(int, int) const;
  Attrib<3, Binding, T, Semantic, true> operator()(int, int, int) const;
  Attrib<4, Binding, T, Semantic, true> operator()(int, int, int, int) const;
  Attrib<1, Binding, T, Semantic, true> operator[](int) const;
  
  template<int N2>
  Attrib<N2, Binding, T, Semantic, true> swiz(int indices[]) const;
  
  Attrib operator-() const;
  private:
    typedef Generic<4, T> ParentType;
};

typedef Attrib<1, INPUT, short, ATTRIB> InputAttrib1s;
typedef Attrib<1, OUTPUT, short, ATTRIB> OutputAttrib1s;
typedef Attrib<1, INOUT, short, ATTRIB> InOutAttrib1s;
typedef Attrib<1, TEMP, short, ATTRIB>  Attrib1s;
typedef Attrib<1, CONST, short, ATTRIB> ConstAttrib1s;
typedef Attrib<2, INPUT, short, ATTRIB> InputAttrib2s;
typedef Attrib<2, OUTPUT, short, ATTRIB> OutputAttrib2s;
typedef Attrib<2, INOUT, short, ATTRIB> InOutAttrib2s;
typedef Attrib<2, TEMP, short, ATTRIB>  Attrib2s;
typedef Attrib<2, CONST, short, ATTRIB> ConstAttrib2s;
typedef Attrib<3, INPUT, short, ATTRIB> InputAttrib3s;
typedef Attrib<3, OUTPUT, short, ATTRIB> OutputAttrib3s;
typedef Attrib<3, INOUT, short, ATTRIB> InOutAttrib3s;
typedef Attrib<3, TEMP, short, ATTRIB>  Attrib3s;
typedef Attrib<3, CONST, short, ATTRIB> ConstAttrib3s;
typedef Attrib<4, INPUT, short, ATTRIB> InputAttrib4s;
typedef Attrib<4, OUTPUT, short, ATTRIB> OutputAttrib4s;
typedef Attrib<4, INOUT, short, ATTRIB> InOutAttrib4s;
typedef Attrib<4, TEMP, short, ATTRIB>  Attrib4s;
typedef Attrib<4, CONST, short, ATTRIB> ConstAttrib4s;


typedef Attrib<1, INPUT, FracUByte, ATTRIB> InputAttrib1fub;
typedef Attrib<1, OUTPUT, FracUByte, ATTRIB> OutputAttrib1fub;
typedef Attrib<1, INOUT, FracUByte, ATTRIB> InOutAttrib1fub;
typedef Attrib<1, TEMP, FracUByte, ATTRIB>  Attrib1fub;
typedef Attrib<1, CONST, FracUByte, ATTRIB> ConstAttrib1fub;
typedef Attrib<2, INPUT, FracUByte, ATTRIB> InputAttrib2fub;
typedef Attrib<2, OUTPUT, FracUByte, ATTRIB> OutputAttrib2fub;
typedef Attrib<2, INOUT, FracUByte, ATTRIB> InOutAttrib2fub;
typedef Attrib<2, TEMP, FracUByte, ATTRIB>  Attrib2fub;
typedef Attrib<2, CONST, FracUByte, ATTRIB> ConstAttrib2fub;
typedef Attrib<3, INPUT, FracUByte, ATTRIB> InputAttrib3fub;
typedef Attrib<3, OUTPUT, FracUByte, ATTRIB> OutputAttrib3fub;
typedef Attrib<3, INOUT, FracUByte, ATTRIB> InOutAttrib3fub;
typedef Attrib<3, TEMP, FracUByte, ATTRIB>  Attrib3fub;
typedef Attrib<3, CONST, FracUByte, ATTRIB> ConstAttrib3fub;
typedef Attrib<4, INPUT, FracUByte, ATTRIB> InputAttrib4fub;
typedef Attrib<4, OUTPUT, FracUByte, ATTRIB> OutputAttrib4fub;
typedef Attrib<4, INOUT, FracUByte, ATTRIB> InOutAttrib4fub;
typedef Attrib<4, TEMP, FracUByte, ATTRIB>  Attrib4fub;
typedef Attrib<4, CONST, FracUByte, ATTRIB> ConstAttrib4fub;


typedef Attrib<1, INPUT, FracUShort, ATTRIB> InputAttrib1fus;
typedef Attrib<1, OUTPUT, FracUShort, ATTRIB> OutputAttrib1fus;
typedef Attrib<1, INOUT, FracUShort, ATTRIB> InOutAttrib1fus;
typedef Attrib<1, TEMP, FracUShort, ATTRIB>  Attrib1fus;
typedef Attrib<1, CONST, FracUShort, ATTRIB> ConstAttrib1fus;
typedef Attrib<2, INPUT, FracUShort, ATTRIB> InputAttrib2fus;
typedef Attrib<2, OUTPUT, FracUShort, ATTRIB> OutputAttrib2fus;
typedef Attrib<2, INOUT, FracUShort, ATTRIB> InOutAttrib2fus;
typedef Attrib<2, TEMP, FracUShort, ATTRIB>  Attrib2fus;
typedef Attrib<2, CONST, FracUShort, ATTRIB> ConstAttrib2fus;
typedef Attrib<3, INPUT, FracUShort, ATTRIB> InputAttrib3fus;
typedef Attrib<3, OUTPUT, FracUShort, ATTRIB> OutputAttrib3fus;
typedef Attrib<3, INOUT, FracUShort, ATTRIB> InOutAttrib3fus;
typedef Attrib<3, TEMP, FracUShort, ATTRIB>  Attrib3fus;
typedef Attrib<3, CONST, FracUShort, ATTRIB> ConstAttrib3fus;
typedef Attrib<4, INPUT, FracUShort, ATTRIB> InputAttrib4fus;
typedef Attrib<4, OUTPUT, FracUShort, ATTRIB> OutputAttrib4fus;
typedef Attrib<4, INOUT, FracUShort, ATTRIB> InOutAttrib4fus;
typedef Attrib<4, TEMP, FracUShort, ATTRIB>  Attrib4fus;
typedef Attrib<4, CONST, FracUShort, ATTRIB> ConstAttrib4fus;


typedef Attrib<1, INPUT, int, ATTRIB> InputAttrib1i;
typedef Attrib<1, OUTPUT, int, ATTRIB> OutputAttrib1i;
typedef Attrib<1, INOUT, int, ATTRIB> InOutAttrib1i;
typedef Attrib<1, TEMP, int, ATTRIB>  Attrib1i;
typedef Attrib<1, CONST, int, ATTRIB> ConstAttrib1i;
typedef Attrib<2, INPUT, int, ATTRIB> InputAttrib2i;
typedef Attrib<2, OUTPUT, int, ATTRIB> OutputAttrib2i;
typedef Attrib<2, INOUT, int, ATTRIB> InOutAttrib2i;
typedef Attrib<2, TEMP, int, ATTRIB>  Attrib2i;
typedef Attrib<2, CONST, int, ATTRIB> ConstAttrib2i;
typedef Attrib<3, INPUT, int, ATTRIB> InputAttrib3i;
typedef Attrib<3, OUTPUT, int, ATTRIB> OutputAttrib3i;
typedef Attrib<3, INOUT, int, ATTRIB> InOutAttrib3i;
typedef Attrib<3, TEMP, int, ATTRIB>  Attrib3i;
typedef Attrib<3, CONST, int, ATTRIB> ConstAttrib3i;
typedef Attrib<4, INPUT, int, ATTRIB> InputAttrib4i;
typedef Attrib<4, OUTPUT, int, ATTRIB> OutputAttrib4i;
typedef Attrib<4, INOUT, int, ATTRIB> InOutAttrib4i;
typedef Attrib<4, TEMP, int, ATTRIB>  Attrib4i;
typedef Attrib<4, CONST, int, ATTRIB> ConstAttrib4i;


typedef Attrib<1, INPUT, double, ATTRIB> InputAttrib1d;
typedef Attrib<1, OUTPUT, double, ATTRIB> OutputAttrib1d;
typedef Attrib<1, INOUT, double, ATTRIB> InOutAttrib1d;
typedef Attrib<1, TEMP, double, ATTRIB>  Attrib1d;
typedef Attrib<1, CONST, double, ATTRIB> ConstAttrib1d;
typedef Attrib<2, INPUT, double, ATTRIB> InputAttrib2d;
typedef Attrib<2, OUTPUT, double, ATTRIB> OutputAttrib2d;
typedef Attrib<2, INOUT, double, ATTRIB> InOutAttrib2d;
typedef Attrib<2, TEMP, double, ATTRIB>  Attrib2d;
typedef Attrib<2, CONST, double, ATTRIB> ConstAttrib2d;
typedef Attrib<3, INPUT, double, ATTRIB> InputAttrib3d;
typedef Attrib<3, OUTPUT, double, ATTRIB> OutputAttrib3d;
typedef Attrib<3, INOUT, double, ATTRIB> InOutAttrib3d;
typedef Attrib<3, TEMP, double, ATTRIB>  Attrib3d;
typedef Attrib<3, CONST, double, ATTRIB> ConstAttrib3d;
typedef Attrib<4, INPUT, double, ATTRIB> InputAttrib4d;
typedef Attrib<4, OUTPUT, double, ATTRIB> OutputAttrib4d;
typedef Attrib<4, INOUT, double, ATTRIB> InOutAttrib4d;
typedef Attrib<4, TEMP, double, ATTRIB>  Attrib4d;
typedef Attrib<4, CONST, double, ATTRIB> ConstAttrib4d;


typedef Attrib<1, INPUT, unsigned char, ATTRIB> InputAttrib1ub;
typedef Attrib<1, OUTPUT, unsigned char, ATTRIB> OutputAttrib1ub;
typedef Attrib<1, INOUT, unsigned char, ATTRIB> InOutAttrib1ub;
typedef Attrib<1, TEMP, unsigned char, ATTRIB>  Attrib1ub;
typedef Attrib<1, CONST, unsigned char, ATTRIB> ConstAttrib1ub;
typedef Attrib<2, INPUT, unsigned char, ATTRIB> InputAttrib2ub;
typedef Attrib<2, OUTPUT, unsigned char, ATTRIB> OutputAttrib2ub;
typedef Attrib<2, INOUT, unsigned char, ATTRIB> InOutAttrib2ub;
typedef Attrib<2, TEMP, unsigned char, ATTRIB>  Attrib2ub;
typedef Attrib<2, CONST, unsigned char, ATTRIB> ConstAttrib2ub;
typedef Attrib<3, INPUT, unsigned char, ATTRIB> InputAttrib3ub;
typedef Attrib<3, OUTPUT, unsigned char, ATTRIB> OutputAttrib3ub;
typedef Attrib<3, INOUT, unsigned char, ATTRIB> InOutAttrib3ub;
typedef Attrib<3, TEMP, unsigned char, ATTRIB>  Attrib3ub;
typedef Attrib<3, CONST, unsigned char, ATTRIB> ConstAttrib3ub;
typedef Attrib<4, INPUT, unsigned char, ATTRIB> InputAttrib4ub;
typedef Attrib<4, OUTPUT, unsigned char, ATTRIB> OutputAttrib4ub;
typedef Attrib<4, INOUT, unsigned char, ATTRIB> InOutAttrib4ub;
typedef Attrib<4, TEMP, unsigned char, ATTRIB>  Attrib4ub;
typedef Attrib<4, CONST, unsigned char, ATTRIB> ConstAttrib4ub;


typedef Attrib<1, INPUT, float, ATTRIB> InputAttrib1f;
typedef Attrib<1, OUTPUT, float, ATTRIB> OutputAttrib1f;
typedef Attrib<1, INOUT, float, ATTRIB> InOutAttrib1f;
typedef Attrib<1, TEMP, float, ATTRIB>  Attrib1f;
typedef Attrib<1, CONST, float, ATTRIB> ConstAttrib1f;
typedef Attrib<2, INPUT, float, ATTRIB> InputAttrib2f;
typedef Attrib<2, OUTPUT, float, ATTRIB> OutputAttrib2f;
typedef Attrib<2, INOUT, float, ATTRIB> InOutAttrib2f;
typedef Attrib<2, TEMP, float, ATTRIB>  Attrib2f;
typedef Attrib<2, CONST, float, ATTRIB> ConstAttrib2f;
typedef Attrib<3, INPUT, float, ATTRIB> InputAttrib3f;
typedef Attrib<3, OUTPUT, float, ATTRIB> OutputAttrib3f;
typedef Attrib<3, INOUT, float, ATTRIB> InOutAttrib3f;
typedef Attrib<3, TEMP, float, ATTRIB>  Attrib3f;
typedef Attrib<3, CONST, float, ATTRIB> ConstAttrib3f;
typedef Attrib<4, INPUT, float, ATTRIB> InputAttrib4f;
typedef Attrib<4, OUTPUT, float, ATTRIB> OutputAttrib4f;
typedef Attrib<4, INOUT, float, ATTRIB> InOutAttrib4f;
typedef Attrib<4, TEMP, float, ATTRIB>  Attrib4f;
typedef Attrib<4, CONST, float, ATTRIB> ConstAttrib4f;


typedef Attrib<1, INPUT, FracInt, ATTRIB> InputAttrib1fi;
typedef Attrib<1, OUTPUT, FracInt, ATTRIB> OutputAttrib1fi;
typedef Attrib<1, INOUT, FracInt, ATTRIB> InOutAttrib1fi;
typedef Attrib<1, TEMP, FracInt, ATTRIB>  Attrib1fi;
typedef Attrib<1, CONST, FracInt, ATTRIB> ConstAttrib1fi;
typedef Attrib<2, INPUT, FracInt, ATTRIB> InputAttrib2fi;
typedef Attrib<2, OUTPUT, FracInt, ATTRIB> OutputAttrib2fi;
typedef Attrib<2, INOUT, FracInt, ATTRIB> InOutAttrib2fi;
typedef Attrib<2, TEMP, FracInt, ATTRIB>  Attrib2fi;
typedef Attrib<2, CONST, FracInt, ATTRIB> ConstAttrib2fi;
typedef Attrib<3, INPUT, FracInt, ATTRIB> InputAttrib3fi;
typedef Attrib<3, OUTPUT, FracInt, ATTRIB> OutputAttrib3fi;
typedef Attrib<3, INOUT, FracInt, ATTRIB> InOutAttrib3fi;
typedef Attrib<3, TEMP, FracInt, ATTRIB>  Attrib3fi;
typedef Attrib<3, CONST, FracInt, ATTRIB> ConstAttrib3fi;
typedef Attrib<4, INPUT, FracInt, ATTRIB> InputAttrib4fi;
typedef Attrib<4, OUTPUT, FracInt, ATTRIB> OutputAttrib4fi;
typedef Attrib<4, INOUT, FracInt, ATTRIB> InOutAttrib4fi;
typedef Attrib<4, TEMP, FracInt, ATTRIB>  Attrib4fi;
typedef Attrib<4, CONST, FracInt, ATTRIB> ConstAttrib4fi;


typedef Attrib<1, INPUT, FracShort, ATTRIB> InputAttrib1fs;
typedef Attrib<1, OUTPUT, FracShort, ATTRIB> OutputAttrib1fs;
typedef Attrib<1, INOUT, FracShort, ATTRIB> InOutAttrib1fs;
typedef Attrib<1, TEMP, FracShort, ATTRIB>  Attrib1fs;
typedef Attrib<1, CONST, FracShort, ATTRIB> ConstAttrib1fs;
typedef Attrib<2, INPUT, FracShort, ATTRIB> InputAttrib2fs;
typedef Attrib<2, OUTPUT, FracShort, ATTRIB> OutputAttrib2fs;
typedef Attrib<2, INOUT, FracShort, ATTRIB> InOutAttrib2fs;
typedef Attrib<2, TEMP, FracShort, ATTRIB>  Attrib2fs;
typedef Attrib<2, CONST, FracShort, ATTRIB> ConstAttrib2fs;
typedef Attrib<3, INPUT, FracShort, ATTRIB> InputAttrib3fs;
typedef Attrib<3, OUTPUT, FracShort, ATTRIB> OutputAttrib3fs;
typedef Attrib<3, INOUT, FracShort, ATTRIB> InOutAttrib3fs;
typedef Attrib<3, TEMP, FracShort, ATTRIB>  Attrib3fs;
typedef Attrib<3, CONST, FracShort, ATTRIB> ConstAttrib3fs;
typedef Attrib<4, INPUT, FracShort, ATTRIB> InputAttrib4fs;
typedef Attrib<4, OUTPUT, FracShort, ATTRIB> OutputAttrib4fs;
typedef Attrib<4, INOUT, FracShort, ATTRIB> InOutAttrib4fs;
typedef Attrib<4, TEMP, FracShort, ATTRIB>  Attrib4fs;
typedef Attrib<4, CONST, FracShort, ATTRIB> ConstAttrib4fs;


typedef Attrib<1, INPUT, char, ATTRIB> InputAttrib1b;
typedef Attrib<1, OUTPUT, char, ATTRIB> OutputAttrib1b;
typedef Attrib<1, INOUT, char, ATTRIB> InOutAttrib1b;
typedef Attrib<1, TEMP, char, ATTRIB>  Attrib1b;
typedef Attrib<1, CONST, char, ATTRIB> ConstAttrib1b;
typedef Attrib<2, INPUT, char, ATTRIB> InputAttrib2b;
typedef Attrib<2, OUTPUT, char, ATTRIB> OutputAttrib2b;
typedef Attrib<2, INOUT, char, ATTRIB> InOutAttrib2b;
typedef Attrib<2, TEMP, char, ATTRIB>  Attrib2b;
typedef Attrib<2, CONST, char, ATTRIB> ConstAttrib2b;
typedef Attrib<3, INPUT, char, ATTRIB> InputAttrib3b;
typedef Attrib<3, OUTPUT, char, ATTRIB> OutputAttrib3b;
typedef Attrib<3, INOUT, char, ATTRIB> InOutAttrib3b;
typedef Attrib<3, TEMP, char, ATTRIB>  Attrib3b;
typedef Attrib<3, CONST, char, ATTRIB> ConstAttrib3b;
typedef Attrib<4, INPUT, char, ATTRIB> InputAttrib4b;
typedef Attrib<4, OUTPUT, char, ATTRIB> OutputAttrib4b;
typedef Attrib<4, INOUT, char, ATTRIB> InOutAttrib4b;
typedef Attrib<4, TEMP, char, ATTRIB>  Attrib4b;
typedef Attrib<4, CONST, char, ATTRIB> ConstAttrib4b;


typedef Attrib<1, INPUT, unsigned short, ATTRIB> InputAttrib1us;
typedef Attrib<1, OUTPUT, unsigned short, ATTRIB> OutputAttrib1us;
typedef Attrib<1, INOUT, unsigned short, ATTRIB> InOutAttrib1us;
typedef Attrib<1, TEMP, unsigned short, ATTRIB>  Attrib1us;
typedef Attrib<1, CONST, unsigned short, ATTRIB> ConstAttrib1us;
typedef Attrib<2, INPUT, unsigned short, ATTRIB> InputAttrib2us;
typedef Attrib<2, OUTPUT, unsigned short, ATTRIB> OutputAttrib2us;
typedef Attrib<2, INOUT, unsigned short, ATTRIB> InOutAttrib2us;
typedef Attrib<2, TEMP, unsigned short, ATTRIB>  Attrib2us;
typedef Attrib<2, CONST, unsigned short, ATTRIB> ConstAttrib2us;
typedef Attrib<3, INPUT, unsigned short, ATTRIB> InputAttrib3us;
typedef Attrib<3, OUTPUT, unsigned short, ATTRIB> OutputAttrib3us;
typedef Attrib<3, INOUT, unsigned short, ATTRIB> InOutAttrib3us;
typedef Attrib<3, TEMP, unsigned short, ATTRIB>  Attrib3us;
typedef Attrib<3, CONST, unsigned short, ATTRIB> ConstAttrib3us;
typedef Attrib<4, INPUT, unsigned short, ATTRIB> InputAttrib4us;
typedef Attrib<4, OUTPUT, unsigned short, ATTRIB> OutputAttrib4us;
typedef Attrib<4, INOUT, unsigned short, ATTRIB> InOutAttrib4us;
typedef Attrib<4, TEMP, unsigned short, ATTRIB>  Attrib4us;
typedef Attrib<4, CONST, unsigned short, ATTRIB> ConstAttrib4us;


typedef Attrib<1, INPUT, FracByte, ATTRIB> InputAttrib1fb;
typedef Attrib<1, OUTPUT, FracByte, ATTRIB> OutputAttrib1fb;
typedef Attrib<1, INOUT, FracByte, ATTRIB> InOutAttrib1fb;
typedef Attrib<1, TEMP, FracByte, ATTRIB>  Attrib1fb;
typedef Attrib<1, CONST, FracByte, ATTRIB> ConstAttrib1fb;
typedef Attrib<2, INPUT, FracByte, ATTRIB> InputAttrib2fb;
typedef Attrib<2, OUTPUT, FracByte, ATTRIB> OutputAttrib2fb;
typedef Attrib<2, INOUT, FracByte, ATTRIB> InOutAttrib2fb;
typedef Attrib<2, TEMP, FracByte, ATTRIB>  Attrib2fb;
typedef Attrib<2, CONST, FracByte, ATTRIB> ConstAttrib2fb;
typedef Attrib<3, INPUT, FracByte, ATTRIB> InputAttrib3fb;
typedef Attrib<3, OUTPUT, FracByte, ATTRIB> OutputAttrib3fb;
typedef Attrib<3, INOUT, FracByte, ATTRIB> InOutAttrib3fb;
typedef Attrib<3, TEMP, FracByte, ATTRIB>  Attrib3fb;
typedef Attrib<3, CONST, FracByte, ATTRIB> ConstAttrib3fb;
typedef Attrib<4, INPUT, FracByte, ATTRIB> InputAttrib4fb;
typedef Attrib<4, OUTPUT, FracByte, ATTRIB> OutputAttrib4fb;
typedef Attrib<4, INOUT, FracByte, ATTRIB> InOutAttrib4fb;
typedef Attrib<4, TEMP, FracByte, ATTRIB>  Attrib4fb;
typedef Attrib<4, CONST, FracByte, ATTRIB> ConstAttrib4fb;


typedef Attrib<1, INPUT, Half, ATTRIB> InputAttrib1h;
typedef Attrib<1, OUTPUT, Half, ATTRIB> OutputAttrib1h;
typedef Attrib<1, INOUT, Half, ATTRIB> InOutAttrib1h;
typedef Attrib<1, TEMP, Half, ATTRIB>  Attrib1h;
typedef Attrib<1, CONST, Half, ATTRIB> ConstAttrib1h;
typedef Attrib<2, INPUT, Half, ATTRIB> InputAttrib2h;
typedef Attrib<2, OUTPUT, Half, ATTRIB> OutputAttrib2h;
typedef Attrib<2, INOUT, Half, ATTRIB> InOutAttrib2h;
typedef Attrib<2, TEMP, Half, ATTRIB>  Attrib2h;
typedef Attrib<2, CONST, Half, ATTRIB> ConstAttrib2h;
typedef Attrib<3, INPUT, Half, ATTRIB> InputAttrib3h;
typedef Attrib<3, OUTPUT, Half, ATTRIB> OutputAttrib3h;
typedef Attrib<3, INOUT, Half, ATTRIB> InOutAttrib3h;
typedef Attrib<3, TEMP, Half, ATTRIB>  Attrib3h;
typedef Attrib<3, CONST, Half, ATTRIB> ConstAttrib3h;
typedef Attrib<4, INPUT, Half, ATTRIB> InputAttrib4h;
typedef Attrib<4, OUTPUT, Half, ATTRIB> OutputAttrib4h;
typedef Attrib<4, INOUT, Half, ATTRIB> InOutAttrib4h;
typedef Attrib<4, TEMP, Half, ATTRIB>  Attrib4h;
typedef Attrib<4, CONST, Half, ATTRIB> ConstAttrib4h;


typedef Attrib<1, INPUT, FracUInt, ATTRIB> InputAttrib1fui;
typedef Attrib<1, OUTPUT, FracUInt, ATTRIB> OutputAttrib1fui;
typedef Attrib<1, INOUT, FracUInt, ATTRIB> InOutAttrib1fui;
typedef Attrib<1, TEMP, FracUInt, ATTRIB>  Attrib1fui;
typedef Attrib<1, CONST, FracUInt, ATTRIB> ConstAttrib1fui;
typedef Attrib<2, INPUT, FracUInt, ATTRIB> InputAttrib2fui;
typedef Attrib<2, OUTPUT, FracUInt, ATTRIB> OutputAttrib2fui;
typedef Attrib<2, INOUT, FracUInt, ATTRIB> InOutAttrib2fui;
typedef Attrib<2, TEMP, FracUInt, ATTRIB>  Attrib2fui;
typedef Attrib<2, CONST, FracUInt, ATTRIB> ConstAttrib2fui;
typedef Attrib<3, INPUT, FracUInt, ATTRIB> InputAttrib3fui;
typedef Attrib<3, OUTPUT, FracUInt, ATTRIB> OutputAttrib3fui;
typedef Attrib<3, INOUT, FracUInt, ATTRIB> InOutAttrib3fui;
typedef Attrib<3, TEMP, FracUInt, ATTRIB>  Attrib3fui;
typedef Attrib<3, CONST, FracUInt, ATTRIB> ConstAttrib3fui;
typedef Attrib<4, INPUT, FracUInt, ATTRIB> InputAttrib4fui;
typedef Attrib<4, OUTPUT, FracUInt, ATTRIB> OutputAttrib4fui;
typedef Attrib<4, INOUT, FracUInt, ATTRIB> InOutAttrib4fui;
typedef Attrib<4, TEMP, FracUInt, ATTRIB>  Attrib4fui;
typedef Attrib<4, CONST, FracUInt, ATTRIB> ConstAttrib4fui;


typedef Attrib<1, INPUT, unsigned int, ATTRIB> InputAttrib1ui;
typedef Attrib<1, OUTPUT, unsigned int, ATTRIB> OutputAttrib1ui;
typedef Attrib<1, INOUT, unsigned int, ATTRIB> InOutAttrib1ui;
typedef Attrib<1, TEMP, unsigned int, ATTRIB>  Attrib1ui;
typedef Attrib<1, CONST, unsigned int, ATTRIB> ConstAttrib1ui;
typedef Attrib<2, INPUT, unsigned int, ATTRIB> InputAttrib2ui;
typedef Attrib<2, OUTPUT, unsigned int, ATTRIB> OutputAttrib2ui;
typedef Attrib<2, INOUT, unsigned int, ATTRIB> InOutAttrib2ui;
typedef Attrib<2, TEMP, unsigned int, ATTRIB>  Attrib2ui;
typedef Attrib<2, CONST, unsigned int, ATTRIB> ConstAttrib2ui;
typedef Attrib<3, INPUT, unsigned int, ATTRIB> InputAttrib3ui;
typedef Attrib<3, OUTPUT, unsigned int, ATTRIB> OutputAttrib3ui;
typedef Attrib<3, INOUT, unsigned int, ATTRIB> InOutAttrib3ui;
typedef Attrib<3, TEMP, unsigned int, ATTRIB>  Attrib3ui;
typedef Attrib<3, CONST, unsigned int, ATTRIB> ConstAttrib3ui;
typedef Attrib<4, INPUT, unsigned int, ATTRIB> InputAttrib4ui;
typedef Attrib<4, OUTPUT, unsigned int, ATTRIB> OutputAttrib4ui;
typedef Attrib<4, INOUT, unsigned int, ATTRIB> InOutAttrib4ui;
typedef Attrib<4, TEMP, unsigned int, ATTRIB>  Attrib4ui;
typedef Attrib<4, CONST, unsigned int, ATTRIB> ConstAttrib4ui;



} // namespace SH
#include "GenericImpl.hpp"
#include "AttribImpl.hpp"

#endif // SH_SHATTRIB_HPP
